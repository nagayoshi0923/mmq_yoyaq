When generating git commit messages, always write them in Japanese.
Use conventional commit format with Japanese descriptions.

Example:
feat: 新機能を追加
fix: バグを修正
docs: ドキュメントを更新
style: コードスタイルを修正
refactor: コードをリファクタリング
test: テストを追加・修正
chore: ビルドプロセスや補助ツールの変更

---

## データベースカラム名の事前確認ルール（必須）🚨

### 基本原則：「実装前にデータベーススキーマを確認する」

**Supabaseクエリを書く前に、必ずカラム名を確認すること。**
カラム名の間違い（例: `response_type` vs `response_status`）は実行時エラーになり、デバッグが困難。

### 確認手順（実装前に必須）

```bash
# 1. テーブルのカラム一覧を確認
# Supabase SQL Editor で実行:
SELECT column_name, data_type FROM information_schema.columns 
WHERE table_name = 'テーブル名' ORDER BY ordinal_position;

# 2. 既存コードで使用されている名前を確認
grep -rn "テーブル名" src --include="*.ts" --include="*.tsx" | head -20
```

### Supabaseクエリ作成時のルール

```typescript
// ✅ 正しい例：事前にカラム名を確認してから実装
// gm_availability_responses テーブルの実際のカラム名: response_status
const { data } = await supabase
  .from('gm_availability_responses')
  .select('staff_id, response_status, available_candidates')  // 正しいカラム名

// ❌ 間違った例：推測でカラム名を書く
const { data } = await supabase
  .from('gm_availability_responses')
  .select('staff_id, response_type, available_candidates')  // カラム名が間違い！
```

### 型定義との整合性

```typescript
// データベースカラム名と型定義は必ず一致させる
interface GMResponse {
  staff_id: string
  response_status: string  // ← DBカラム名と同じ
  available_candidates: number[]
}
```

---

## データ命名規則（必須）

### 基本原則：「既存の名前を確認してから命名する」

新しいフィールド/変数を作成する前に、必ず以下を確認：

1. **データベースのカラム名を確認** - Supabaseのテーブル定義が正解
2. **型定義を確認** - `src/types/index.ts` で既存の命名パターンを確認
3. **類似フィールドを検索** - 同じ概念に別名がないか `grep` で確認

### 命名規則

| 場所 | ケース | 例 |
|------|--------|-----|
| データベースカラム | snake_case | `participant_count`, `store_id` |
| TypeScript型定義 | snake_case（DBに合わせる） | `participant_count: number` |
| React state/変数 | camelCase | `participantCount`, `storeId` |
| コンポーネントProps | camelCase | `onParticipantChange` |

### 禁止事項

❌ 同じ概念に複数の名前を作らない
- 悪い例: `discord_user_id` と `discord_id` を混在
- 悪い例: `min_players` と `player_count_min` を混在
- 悪い例: `participant_count` と `current_participants` を混在

❌ 既存のパターンを無視して新しい名前を作らない
- 新規追加時は必ず既存の類似フィールドを確認

### 新しいフィールド追加時のチェックリスト

```
□ データベースにカラムを追加した場合
  → src/types/index.ts の該当interfaceに同じ名前で追加
  
□ フロントエンドで新しいプロパティを使う場合
  → 型定義に存在するか確認（なければ追加）
  
□ 既存と似た名前のフィールドがある場合
  → 既存の命名パターンに合わせる（新しい名前を作らない）
```

### 確認コマンド

```bash
# 類似の命名がないか確認
grep -r "participant" src/types/

# データベースと型定義の整合性確認
npm run db:check
```

---

## TypeScript 型安全ルール（必須）

### ビルド前の型チェック必須
- `npm run build` は必ず `tsc --noEmit` を実行してから `vite build` を行う
- 型エラーがある状態でのデプロイは禁止
- 急ぎの場合のみ `npm run build:fast` を使用可（型チェックをスキップ）

### コード変更時のルール
1. **新しいプロパティを追加する場合**: 必ず対応する型定義（interface/type）も更新する
2. **データベースカラム名を使用する場合**: types/index.ts の型定義と一致させる
3. **Supabaseクエリの結果を使用する場合**: 適切な型アサーションを行う
4. **コンポーネントにpropsを追加する場合**: Props interfaceを必ず定義する

### 型エラーの対処
- `Property 'xxx' does not exist` → 型定義に追加するか、プロパティ名を修正
- `Type 'A' is not assignable to type 'B'` → 型の不整合を解消
- `Module has no exported member` → インポート先を確認、または `npm ci` を実行

### 定期チェック推奨
```bash
npm run typecheck  # 型チェックのみ実行
```

---

## マルチテナント対応ルール（必須）🚨

### 基本原則：「organization_id を必ず設定・フィルタする」

このプロジェクトはマルチテナント（複数組織）に対応しています。
**organization_id の設定漏れは他組織のデータ漏洩につながる重大なセキュリティ問題です。**

### データベース操作時のルール

#### 1. INSERT / UPSERT 時
```typescript
// ✅ 正しい例
const orgId = await getCurrentOrganizationId()
await supabase.from('reservations').insert({
  ...data,
  organization_id: orgId  // 必須
})

// ❌ 間違った例
await supabase.from('reservations').insert(data)  // organization_id がない！
```

#### 2. SELECT 時
```typescript
// ✅ 正しい例
const orgId = await getCurrentOrganizationId()
let query = supabase.from('reservations').select('*')
if (orgId) {
  query = query.eq('organization_id', orgId)
}

// ❌ 間違った例
await supabase.from('reservations').select('*')  // フィルタなし！
```

#### 3. UPDATE / DELETE 時
```typescript
// ID で特定する場合は RLS で保護されるため OK
// ただし、範囲更新/削除する場合は organization_id フィルタ必須
```

### 例外（organization_id 不要なテーブル）

以下のテーブルは organization_id 不要：
- `users` - 認証テーブル
- `organizations` - 組織テーブル自体
- `authors` - 共有マスタデータ
- `auth_logs` - システムログ

### 新機能追加時のチェックリスト

```
□ INSERT/UPSERT に organization_id を含めているか？
□ SELECT に organization_id フィルタを追加しているか？
□ 新しいテーブルに organization_id カラムがあるか？
□ 新しいテーブルに RLS ポリシーを設定したか？
□ organization_id カラムにインデックスがあるか？
```

### 確認コマンド

```bash
# organization_id が漏れている INSERT を検索
grep -rn "\.insert(" src --include="*.ts" --include="*.tsx" | xargs -I {} sh -c 'grep -L "organization_id" {}'

# RLS ポリシーの確認（Supabase SQL Editor で実行）
SELECT tablename, policyname FROM pg_policies WHERE schemaname = 'public';
```

### 多層防御

1. **RLS（Row Level Security）** - データベースレベルで強制保護
2. **コード側フィルタ** - 明示的な organization_id フィルタ
3. **インデックス** - パフォーマンス確保

**RLS だけでも保護されますが、コード側でも必ずフィルタを追加してください。**
